import React from "react";
import { render, waitForElement } from "@testing-library/react";
import ThemeProvider, { useTheme } from "../ThemeProvider";

jest.mock("@cobalt/theme-base", () => ({
  primary600: {
    css: "--primary-600",
    value: "blue"
  }
}));

describe("<ThemeProvider />", () => {
  it("renders a placeholder while theme is loading", () => {
    const themeLoader = () =>
      new Promise<object>(resolve => setTimeout(() => resolve({}), 500));
    const { getByText } = render(
      <ThemeProvider placeholder={<p>Loading...</p>} loader={themeLoader}>
        This will not be rendered
      </ThemeProvider>
    );

    expect(getByText("Loading...")).toBeDefined();
  });

  it("loads a theme", async () => {
    const themeLoader = () =>
      Promise.resolve({
        orange600: {
          css: "--orange-600",
          value: "orange"
        }
      });
    const handleLoad = jest.fn();
    const { getByText } = render(
      <ThemeProvider
        placeholder={<p>Loading...</p>}
        loader={themeLoader}
        onLoad={handleLoad}
      >
        This will be rendered
      </ThemeProvider>
    );

    await waitForElement(() => getByText("This will be rendered"));

    expect(handleLoad).toHaveBeenCalled();
  });

  it("merges the base theme with the loaded theme", async () => {
    const Color = () => {
      const theme = useTheme();
      return <span>{theme.primary600}</span>;
    };
    const themeLoader = () =>
      Promise.resolve({
        primary600: {
          css: "--primary-600",
          value: "orange"
        }
      });
    const { getByText } = render(
      <ThemeProvider placeholder={<p>Loading...</p>} loader={themeLoader}>
        <Color />
      </ThemeProvider>
    );

    await waitForElement(() => getByText("orange"));
  });

  it("loads a fallback theme when theme is not loaded", async () => {
    const themeLoader = () => Promise.reject();
    const handleError = jest.fn();
    const { getByText } = render(
      <ThemeProvider
        placeholder={<p>Loading...</p>}
        loader={themeLoader}
        onError={handleError}
      >
        This will be rendered
      </ThemeProvider>
    );

    await waitForElement(() => getByText("This will be rendered"));

    expect(handleError).toHaveBeenCalled();
  });

  it("does not render the contents when there is an error loading a theme", async () => {
    const themeLoader = () => Promise.reject();
    const handleError = jest.fn();

    const { getByText } = render(
      <ThemeProvider
        placeholder={<p>Loading...</p>}
        loader={themeLoader}
        onError={handleError}
      >
        This will not be rendered
      </ThemeProvider>
    );

    await waitForElement(() => getByText("Loading..."));

    expect(handleError).toHaveBeenCalledTimes(1);
  });

  it("supports className property", async () => {
    const className = "some-class-name";

    const { getByTestId } = render(
      <ThemeProvider className={className} data-testid="test-classname">
        content
      </ThemeProvider>
    );
    let element: HTMLElement;
    await waitForElement(() => (element = getByTestId("test-classname")));

    expect(element!.className).toBe(className);
  });

  it("supports the style prop, whose values are then merged with the provider and theme styles", async () => {
    const { getByTestId } = render(
      <ThemeProvider style={{ display: "inline" }} data-testid="test-style">
        content
      </ThemeProvider>
    );
    let element: HTMLElement;
    await waitForElement(() => (element = getByTestId("test-style")));

    expect(element!.style.display).toBe("inline");
    // test also for other style properties also meant to be there
    expect(element!.style.height).toBe("100%");
  });
});

describe("useTheme", () => {
  const Wrapper = (props: { children: React.ReactNode }) => {
    const theme = useTheme();

    return <span style={{ color: theme.primary600 }}>{props.children}</span>;
  };

  it("exports base theme as context", async () => {
    const { getByText } = render(
      <ThemeProvider placeholder={<p>Loading...</p>}>
        <Wrapper>Base theme!</Wrapper>
      </ThemeProvider>
    );

    const wrapper = await waitForElement(() => getByText("Base theme!"));

    expect(wrapper.style.color).toBe("blue");
  });

  it("throws an error when hook is used without a provider", () => {
    // Even though the error is caught, it still gets printed to the console
    // so we mock that out to avoid the wall of red text.
    const spy = jest.spyOn(console, "error");
    spy.mockImplementation(() => {});

    expect(() => render(<Wrapper>Boom!</Wrapper>)).toThrowError(
      "You must use a ThemeProvider to get a theme."
    );

    spy.mockRestore();
  });

  it("renders full height of its parent", async () => {
    const { getByText } = render(
      <ThemeProvider placeholder={<p>Loading...</p>}>
        This will be rendered
      </ThemeProvider>
    );

    await waitForElement(() => getByText("This will be rendered"));

    expect(getByText("This will be rendered").style.height).toBe("100%");
  });
});
