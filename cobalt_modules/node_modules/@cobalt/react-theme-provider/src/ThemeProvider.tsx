import React, {
  useState,
  useEffect,
  useRef,
  FunctionComponent,
  CSSProperties,
  ReactNode,
  createContext,
  useContext
} from "react";
import baseTheme from "@cobalt/theme-base";
import "@cobalt/css-core";

export interface ThemeObject {
  [k: string]: {
    css: string;
    value: string;
  };
}

export type Theme = {
  [k in keyof typeof baseTheme]: string;
};

export interface Props {
  children: ReactNode;
  /** Rendered while a theme is not loaded. */
  placeholder?: ReactNode;
  /** Returns a promise with the loaded theme. */
  loader?: () => Promise<Partial<ThemeObject>>;
  /** Callback that is called when a theme is loaded. */
  onLoad?: () => void;
  /** Callback that is called when a theme is not loaded. */
  onError?: () => void;
  /** Load fallback theme when theme cannot be loaded. */
  useFallback?: boolean;
  /** The className to be added to the div element that injects the styles*/
  className?: string;
  /** Allow the div to receive style properties to be added to the theme styles   */
  style?: CSSProperties;
}

interface ThemeProperties {
  styles: CSSProperties;
  theme: Theme;
}

function getThemeProperties(themeObject: ThemeObject): ThemeProperties {
  return Object.entries(themeObject).reduce<ThemeProperties>(
    (acc, [k, { css, value }]) => {
      return {
        styles: { ...acc.styles, [css]: value },
        theme: { ...acc.theme, [k]: value }
      };
    },
    { styles: {}, theme: {} as Theme }
  );
}

const ThemeContext = createContext<Theme | null>(null);
const defaultThemeLoader = () => Promise.resolve(baseTheme);

function useTheme<T extends Theme>(): T {
  const theme = useContext(ThemeContext);

  if (!theme) {
    throw new Error("You must use a ThemeProvider to get a theme.");
  }

  return theme as T;
}

const providerStyles = {
  height: "100%"
};

const ThemeProvider: FunctionComponent<Props> = ({
  children,
  placeholder,
  loader,
  onLoad,
  onError,
  useFallback = true,
  style = {},
  ...props
}) => {
  const [theme, setTheme] = useState<Partial<ThemeObject> | null>(null);
  const isMounted = useRef(false);

  const themeLoader = loader || defaultThemeLoader;

  useEffect(() => {
    isMounted.current = true;

    themeLoader()
      .then(data => {
        if (isMounted.current) {
          setTheme(data);
          onLoad && onLoad();
        }
      })
      .catch(() => {
        if (isMounted.current) {
          if (useFallback) {
            setTheme(baseTheme);
          }
          onError && onError();
        }
      });

    return () => {
      isMounted.current = false;
    };
  }, [themeLoader, useFallback, onLoad, onError]);

  if (!theme) {
    return placeholder ? <div style={providerStyles}>{placeholder}</div> : null;
  }

  const mergedTheme = { ...baseTheme, ...theme };
  const { styles, theme: themeValue } = getThemeProperties(mergedTheme);

  return (
    <ThemeContext.Provider value={themeValue}>
      <div {...props} style={{ ...providerStyles, ...styles, ...style }}>
        {children}
      </div>
    </ThemeContext.Provider>
  );
};

export default ThemeProvider;
export { ThemeContext, useTheme };
