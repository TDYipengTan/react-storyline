import * as luxon from "luxon";
import { DaysType, DaysRange, Weekday, Weekdays, SelectionType } from "./types";

const PREVIOUS_MONTH_DAY = 0;
const NEXT_MONTH_DAY = 32;

luxon.Settings.defaultLocale = "en";

const getLuxonDate = (year: number, month?: number, day?: number) => {
  return luxon.DateTime.fromObject({ year, month, day });
};

export const validateDates = (year: number, month: number) => {
  const date = getLuxonDate(year, month);

  if (!date.isValid) {
    throw new Error(
      "Invalid value: the specified value for month or year is not valid."
    );
  }
};

export const getWeekDays = (weekStart: Weekday) => {
  const weekDaysShort = luxon.Info.weekdays("short");
  const weekStartKey = weekDaysShort.findIndex(
    (weekDay: string) => weekDay.toUpperCase() === weekStart
  );

  const weekDaysUppercase = weekDaysShort.map(
    weekday => weekday.toUpperCase() as keyof Weekdays
  );

  return [
    ...weekDaysUppercase.slice(weekStartKey),
    ...weekDaysUppercase.slice(0, weekStartKey)
  ];
};

export const getEmptyDays = (
  weekStart: Weekday,
  year: number,
  month: number
) => {
  const dayOne = getLuxonDate(year, month, 1);

  const firstDayInMonthUpper = dayOne.weekdayShort.toUpperCase() as Weekday;

  const nrEmptyDays = getWeekDays(weekStart).lastIndexOf(firstDayInMonthUpper);

  return new Array(nrEmptyDays).fill(0);
};

export const getDaysInMonth = (year: number, month: number) => {
  const nrDaysInMonth = getLuxonDate(year, month).daysInMonth;

  return new Array(nrDaysInMonth).fill(0);
};

export const containsDay = (
  daysArray: DaysType,
  day: number
): SelectionType => {
  // Verify if single selection
  if (daysArray.map(date => Number(date)).includes(day)) return "single";

  // Verify if range selection
  const datesRanges = daysArray.filter(
    (item: any): item is DaysRange =>
      typeof item === "object" && ("start" in item || "end" in item)
  );

  if (datesRanges.length === 0) return;

  const rangeMatch = datesRanges.filter(range => {
    const { start = PREVIOUS_MONTH_DAY, end = NEXT_MONTH_DAY } = range;

    return day >= Number(start) && day <= Number(end);
  })[0];

  if (!rangeMatch) return;

  const { start = PREVIOUS_MONTH_DAY, end = NEXT_MONTH_DAY } = rangeMatch;

  if (day === Number(start)) {
    return "first";
  } else if (day === Number(end)) {
    return "last";
  } else {
    return "between";
  }
};
