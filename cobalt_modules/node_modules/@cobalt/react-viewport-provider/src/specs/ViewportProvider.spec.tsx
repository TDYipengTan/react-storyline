import React from "react";
import { render, fireEvent } from "@testing-library/react";

import ViewportProvider, {
  Provider,
  useViewport,
  ViewportContext,
} from "../ViewportProvider";

const ViewportConsumer = () => {
  const viewport = useViewport();
  return <span>{viewport}</span>;
};

function ViewportTest(width: number, viewportSize: string) {
  const win = { ...window, innerWidth: width };
  const { container, getByText } = render(
    <Provider target={win}>
      <ViewportConsumer />
    </Provider>
  );

  fireEvent(container, new Event("resize"));

  getByText(viewportSize);
}

function ViewportCustomTargetTest(width: number, viewportSize: string) {
  const div = document.createElement("div");
  div.style.width = `${width}px`;

  const { container, getByText } = render(
    <ViewportProvider target={div}>
      <ViewportConsumer />
    </ViewportProvider>,
    {
      container: div,
    }
  );

  fireEvent(container, new Event("resize"));
  getByText(viewportSize);
}

describe("<ViewportProvider />", () => {
  it("passes the value small to the consumer when the window width is 0", () => {
    ViewportTest(0, "small");
  });

  it("passes the value small to the consumer when the window width is 640", () => {
    ViewportTest(640, "small");
  });

  it("passes the value medium to the consumer when the window width is 641", () => {
    ViewportTest(641, "medium");
  });

  it("passes the value medium to the consumer when the window width is 960", () => {
    ViewportTest(960, "medium");
  });

  it("passes the value large to the consumer when the window width is 961", () => {
    ViewportTest(961, "large");
  });

  it("passes the value large to the consumer when the window width is infinity", () => {
    ViewportTest(Infinity, "large");
  });
});

describe("<ViewportProvider /> with custom element as target", () => {
  beforeAll(() => {
    window.ResizeObserver =
      window.ResizeObserver ||
      jest.fn().mockImplementation(() => ({
        disconnect: jest.fn(),
        observe: jest.fn(),
        unobserve: jest.fn(),
      }));

    Object.defineProperties(window.HTMLElement.prototype, {
      offsetWidth: {
        get() {
          return parseFloat(this.style.width) || 0;
        },
      },
    });
  });
  it("passes the value small to the consumer when the window width is 0", () => {
    ViewportCustomTargetTest(0, "small");
  });

  it("passes the value small to the consumer when the window width is 640", () => {
    ViewportCustomTargetTest(640, "small");
  });

  it("passes the value medium to the consumer when the window width is 641", () => {
    ViewportCustomTargetTest(641, "medium");
  });

  it("passes the value medium to the consumer when the window width is 960", () => {
    ViewportCustomTargetTest(960, "medium");
  });

  it("passes the value large to the consumer when the window width is 961", () => {
    ViewportCustomTargetTest(961, "large");
  });
});

describe("useViewport", () => {
  it("returns the active viewport", () => {
    const { getByText } = render(
      <ViewportContext.Provider value="small">
        <ViewportConsumer />
      </ViewportContext.Provider>
    );

    expect(getByText("small")).toBeDefined();
  });

  it("throws an error when hook is used without a provider", () => {
    // Even though the error is caught, it still gets printed to the console
    // so we mock that out to avoid the wall of red text.
    const spy = jest.spyOn(console, "error");
    spy.mockImplementation(() => {});

    expect(() =>
      render(
        <ViewportContext.Provider value={null}>
          <ViewportConsumer />
        </ViewportContext.Provider>
      )
    ).toThrowError("You must use a ViewportProvider to get a viewport.");

    spy.mockRestore();
  });
});
