import { useState, useEffect, useContext, CSSProperties } from "react";
import { useInView } from "react-intersection-observer";
import { ContainerContext } from "./Container";
import throttle from "lodash.throttle";

export type CardinalPoint = "N" | "NE" | "E" | "SE" | "S" | "SW" | "W" | "NW";

/** Special cardinal points.
 * Represent when the element needs to be positionined in an unknown origin and direction pair */
type ComplexCardinal = CardinalPoint | "NX" | "SX" | "XE" | "XW";
interface Point {
  x: number;
  y: number;
}

interface Shift {
  x: string;
  y: string;
}

export interface Options {
  origin: CardinalPoint;
  direction: CardinalPoint;
  autoGap?: number;
  gapX?: number;
  gapY?: number;
}

interface Position {
  position: CSSProperties["position"];
  top: number;
  left: number;
  transform: string;
}

interface Coordinates {
  origin: ComplexCardinal;
  direction: ComplexCardinal;
}

interface CoordinatesState extends Coordinates {
  shouldUpdatePosition: number;
}

const BASE_UNIT_SPACING = 4;

function getShiftFor(coordinate: ComplexCardinal): Shift {
  switch (coordinate) {
    case "E":
      return { x: "0px", y: "-50%" };
    case "N":
      return { x: "-50%", y: "-100%" };
    case "NE":
    case "NX":
      return { x: "0px", y: "-100%" };
    case "NW":
      return { x: "-100%", y: "-100%" };
    case "W":
      return { x: "-100%", y: "-50%" };
    case "S":
      return { x: "-50%", y: "0px" };
    case "SE":
    case "SX":
    case "XE":
      return { x: "0px", y: "0px" };
    case "SW":
    case "XW":
      return { x: "-100%", y: "0px" };
  }
}

function getOriginFrom(
  node: HTMLElement,
  coordinate: ComplexCardinal,
  isRelative?: boolean
): Point {
  let { width, height, top, left } = node.getBoundingClientRect();

  if (isRelative) {
    top = node.offsetTop;
    left = node.offsetLeft;
  }

  const bottom = top + height;
  const right = left + width;
  const middleX = left + width / 2;
  const middleY = top + height / 2;

  switch (coordinate) {
    case "E":
      return { x: right, y: middleY };
    case "N":
      return { x: middleX, y: top };
    case "NE":
      return { x: right, y: top };
    case "NW":
      return { x: left, y: top };
    case "W":
      return { x: left, y: middleY };
    case "S":
      return { x: middleX, y: bottom };
    case "SE":
      return { x: right, y: bottom };
    case "SW":
      return { x: left, y: bottom };
    case "NX":
      return { x: BASE_UNIT_SPACING, y: top };
    case "SX":
      return { x: BASE_UNIT_SPACING, y: bottom };
    case "XE":
      return { x: right, y: BASE_UNIT_SPACING };
    case "XW":
      return { x: left, y: BASE_UNIT_SPACING };
  }
}

function getLeftGap(
  gap: number,
  origin: ComplexCardinal,
  direction: ComplexCardinal
): number {
  const points: ComplexCardinal[] = ["W", "SW", "NW", "XW"];

  if (origin === "W" && points.includes(direction)) {
    return -gap;
  }

  if (
    points.includes(origin) &&
    points.includes(direction) &&
    (origin !== direction || origin === "XW")
  ) {
    return -gap;
  }

  return 0;
}

function getRightGap(
  gap: number,
  origin: ComplexCardinal,
  direction: ComplexCardinal
): number {
  const points: ComplexCardinal[] = ["E", "SE", "NE", "XE"];

  if (origin === "E" && points.includes(direction)) {
    return gap;
  }

  if (
    points.includes(origin) &&
    points.includes(direction) &&
    (origin !== direction || origin === "XE")
  ) {
    return gap;
  }

  return 0;
}

function getTopGap(
  gap: number,
  origin: ComplexCardinal,
  direction: ComplexCardinal
): number {
  const points: ComplexCardinal[] = ["N", "NE", "NW", "NX"];

  if (
    (origin === "N" && points.includes(direction)) ||
    (points.includes(origin) && points.includes(direction))
  ) {
    return -gap;
  }

  return 0;
}

function getBottomGap(
  gap: number,
  origin: ComplexCardinal,
  direction: ComplexCardinal
): number {
  const points: ComplexCardinal[] = ["S", "SE", "SW", "SX"];

  if (
    (origin === "S" && points.includes(direction)) ||
    (points.includes(origin) && points.includes(direction))
  ) {
    return gap;
  }

  return 0;
}

function getGap(
  gap: number,
  origin: ComplexCardinal,
  direction: ComplexCardinal
): Point {
  const leftGap = getLeftGap(gap, origin, direction);
  const rightGap = getRightGap(gap, origin, direction);
  const topGap = getTopGap(gap, origin, direction);
  const bottomGap = getBottomGap(gap, origin, direction);

  const gapX = leftGap || rightGap;
  const gapY = topGap || bottomGap;

  return { x: gapX, y: gapY };
}

function calculateMostSpace(
  anchor: DOMRect | ClientRect,
  element: DOMRect | ClientRect
): { vertical: string; horizontal: string; major: string } {
  const { innerHeight, innerWidth } = window;

  type DirectionValuePair = { direction: string; value: number };

  const remainingTop: DirectionValuePair = {
    direction: "top",
    value: anchor.top
  };
  const remainingLeft: DirectionValuePair = {
    direction: "left",
    value: anchor.left
  };
  const remainingRight: DirectionValuePair = {
    direction: "right",
    value: innerWidth - (anchor.left + anchor.width)
  };
  const remainingBottom: DirectionValuePair = {
    direction: "bottom",
    value: innerHeight - (anchor.top + anchor.height)
  };

  const biggestVertical =
    remainingBottom.value > remainingTop.value ? remainingBottom : remainingTop;

  const biggestHorizontal =
    remainingLeft.value > remainingRight.value ? remainingLeft : remainingRight;

  if (
    remainingRight.value + anchor.width < element.width &&
    remainingLeft.value + anchor.width < element.width
  ) {
    return {
      vertical: biggestVertical.direction,
      horizontal: "none",
      major: biggestVertical.direction
    };
  }

  if (
    remainingTop.value + anchor.height < element.height &&
    remainingBottom.value + anchor.height < element.height
  ) {
    return {
      vertical: "none",
      horizontal: biggestHorizontal.direction,
      major: biggestHorizontal.direction
    };
  }

  return {
    vertical: biggestVertical.direction,
    horizontal: biggestHorizontal.direction,
    major:
      biggestVertical.value >= biggestHorizontal.value
        ? biggestVertical.direction
        : biggestHorizontal.direction
  };
}

function getOptimalPositioning(
  anchor: HTMLElement,
  intersectionEntry: IntersectionObserverEntry
): Coordinates {
  const { vertical, horizontal, major } = calculateMostSpace(
    anchor.getBoundingClientRect(),
    intersectionEntry.boundingClientRect
  );

  switch (major) {
    case "top":
      switch (horizontal) {
        case "right":
          return { origin: "NW", direction: "NE" };
        case "left":
          return { origin: "NE", direction: "NW" };
        default:
          return { origin: "NX", direction: "NX" };
      }
    case "bottom":
      switch (horizontal) {
        case "right":
          return { origin: "SW", direction: "SE" };
        case "left":
          return { origin: "SE", direction: "SW" };
        default:
          return { origin: "SX", direction: "SX" };
      }
    case "right":
      switch (vertical) {
        case "top":
          return { origin: "SE", direction: "NE" };
        case "bottom":
          return { origin: "NE", direction: "SE" };
        default:
          return { origin: "XE", direction: "XE" };
      }
    case "left":
    default:
      switch (vertical) {
        case "top":
          return { origin: "SW", direction: "NW" };
        case "bottom":
          return { origin: "NW", direction: "SW" };
        default:
          return { origin: "XW", direction: "XW" };
      }
  }
}

function usePosition(
  anchor: HTMLElement | null,
  { origin, direction, autoGap = 0, gapX = 0, gapY = 0 }: Options
): { position: Position | undefined; elementRef: any } {
  const [coordinatesState, setCoordinatesState] = useState<CoordinatesState>({
    origin,
    direction,
    shouldUpdatePosition: 1
  });

  const isRelative = useContext(ContainerContext) === "relative";

  const { ref, inView, entry: intersectionEntry } = useInView({
    threshold: 1,
    initialInView: true
  });

  const elementToPositionIsRendered = !!(
    intersectionEntry &&
    intersectionEntry.target &&
    intersectionEntry.target.clientHeight &&
    intersectionEntry.target.clientWidth
  );

  const specialCoordinates: ComplexCardinal[] = ["NX", "XE", "SX", "XW"];
  const shouldResetPosition =
    !!coordinatesState.shouldUpdatePosition &&
    specialCoordinates.includes(coordinatesState.origin) &&
    specialCoordinates.includes(coordinatesState.direction);

  useEffect(() => {
    if (
      !intersectionEntry ||
      (intersectionEntry && !elementToPositionIsRendered)
    ) {
      setCoordinatesState(previousState => ({
        ...previousState,
        origin,
        direction
      }));
      return;
    }

    if (shouldResetPosition) {
      setCoordinatesState({ origin, direction, shouldUpdatePosition: 0 });
      return;
    }

    if (anchor && intersectionEntry && !inView) {
      setCoordinatesState(previousState => ({
        ...previousState,
        ...getOptimalPositioning(anchor, intersectionEntry)
      }));
    }
  }, [
    direction,
    inView,
    origin,
    intersectionEntry,
    anchor,
    shouldResetPosition,
    elementToPositionIsRendered
  ]);

  useEffect(() => {
    const target = window;
    const resizeCallback = throttle(() => {
      setCoordinatesState(previousState => ({
        ...previousState,
        shouldUpdatePosition: previousState.shouldUpdatePosition + 1
      }));
    }, 200);

    const scrollCallback = () => {
      setCoordinatesState(previousState => ({
        ...previousState,
        shouldUpdatePosition: previousState.shouldUpdatePosition + 1
      }));
    };

    target.addEventListener("resize", resizeCallback, true);
    target.addEventListener("scroll", scrollCallback, true);

    return () => {
      if (!target || !target.removeEventListener) return;

      target.removeEventListener("resize", resizeCallback, true);
      target.removeEventListener("scroll", scrollCallback, true);
    };
  }, []);

  if (!anchor) {
    return { position: undefined, elementRef: ref };
  }

  const point = getOriginFrom(anchor, coordinatesState.origin, isRelative);
  const gap = getGap(
    autoGap,
    coordinatesState.origin,
    coordinatesState.direction
  );
  const shift = getShiftFor(coordinatesState.direction);

  return {
    position: {
      position: "absolute",
      left: Math.round(point.x + gap.x + gapX),
      top: Math.round(point.y + gap.y + gapY),
      transform: `translate3d(${shift.x}, ${shift.y}, 0)`
    },
    elementRef: ref
  };
}

export default usePosition;
