import React, { useCallback, useState } from "react";
import { render } from "@testing-library/react";
import { mockAllIsIntersecting } from "react-intersection-observer/test-utils";
import usePosition, { CardinalPoint } from "../usePosition";
import Container from "../Container";

interface Props {
  origin: CardinalPoint;
  direction: CardinalPoint;
  autoGap?: number;
  gapX?: number;
  gapY?: number;
  getPosition?: boolean;
}

function extendNode(
  node: HTMLDivElement,
  width: number,
  height: number
): HTMLDivElement {
  return {
    ...node,
    offsetTop: 20,
    offsetLeft: 20,
    getBoundingClientRect() {
      return {
        width,
        height,
        top: 0,
        left: 0,
        right: width,
        bottom: height,
        x: 0,
        y: 0,
        toJSON: () => {}
      };
    }
  };
}

const Component: React.FC<Props> = ({
  origin,
  direction,
  autoGap = 10,
  gapX,
  gapY,
  getPosition = false
}) => {
  const [node, setNode] = useState<HTMLDivElement | null>(null);
  const { position, elementRef } = usePosition(node, {
    origin,
    direction,
    autoGap,
    gapX,
    gapY
  });
  const s = useCallback((node: HTMLDivElement) => {
    setNode(extendNode(node, 100, 50));
  }, []);

  return (
    <>
      <div ref={s} />
      <span ref={elementRef} data-testid="position">
        {position
          ? getPosition
            ? `${position.position}`
            : `(${position.left}, ${position.top}, ${position.transform})`
          : "No position"}
      </span>
    </>
  );
};

describe("usePosition", () => {
  const originalClientHeight =
    Object.getOwnPropertyDescriptor(HTMLElement.prototype, "clientHeight") ||
    200;
  const originalClientWidth =
    Object.getOwnPropertyDescriptor(HTMLElement.prototype, "clientWidth") ||
    300;

  beforeAll(() => {
    Object.defineProperty(HTMLElement.prototype, "clientHeight", {
      configurable: true,
      value: 200
    });
    Object.defineProperty(HTMLElement.prototype, "clientWidth", {
      configurable: true,
      value: 300
    });
  });

  afterAll(() => {
    Object.defineProperty(
      HTMLElement.prototype,
      "clientHeight",
      { value: originalClientHeight }
    );
    Object.defineProperty(
      HTMLElement.prototype,
      "clientWidth",
      { value: originalClientWidth }
    );
  });

  it("returns with position:absolute attribute", () => {
    const { getByTestId } = render(
      <Component origin="N" direction="N" getPosition />
    );
    const content = getByTestId("position");
    mockAllIsIntersecting(true);

    expect(content.textContent).toBe("absolute");
  });

  it("returns position with horizontal gap", () => {
    const { getByTestId } = render(
      <Component origin="NE" direction="N" gapX={25} />
    );
    const content = getByTestId("position");
    mockAllIsIntersecting(true);

    expect(content.textContent).toBe("(125, -10, translate3d(-50%, -100%, 0))");
  });

  it("returns position with vertical gap", () => {
    const { getByTestId } = render(
      <Component origin="NE" direction="N" gapY={25} />
    );
    const content = getByTestId("position");
    mockAllIsIntersecting(true);

    expect(content.textContent).toBe("(100, 15, translate3d(-50%, -100%, 0))");
  });

  describe("when is in a relative context", () => {
    it("returns the position relative to Container", () => {
      const { getByTestId } = render(
        <Container>
          <Component origin="NW" direction="E" />
        </Container>
      );
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      // Should return Component's position offset (left, top, ...) instead getBoundingClientRect
      expect(content.textContent).toBe("(20, 20, translate3d(0px, -50%, 0))");
    });
  });

  describe("from origin N", () => {
    it("returns the position for direction N", () => {
      const { getByTestId } = render(<Component origin="N" direction="N" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe(
        "(50, -10, translate3d(-50%, -100%, 0))"
      );
    });

    it("returns the position for direction NE", () => {
      const { getByTestId } = render(<Component origin="N" direction="NE" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(50, -10, translate3d(0px, -100%, 0))");
    });

    it("returns the position for direction E", () => {
      const { getByTestId } = render(<Component origin="N" direction="E" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(50, 0, translate3d(0px, -50%, 0))");
    });

    it("returns the position for direction SE", () => {
      const { getByTestId } = render(<Component origin="N" direction="SE" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(50, 0, translate3d(0px, 0px, 0))");
    });

    it("returns the position for direction S", () => {
      const { getByTestId } = render(<Component origin="N" direction="S" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(50, 0, translate3d(-50%, 0px, 0))");
    });

    it("returns the position for direction SW", () => {
      const { getByTestId } = render(<Component origin="N" direction="SW" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(50, 0, translate3d(-100%, 0px, 0))");
    });

    it("returns the position for direction W", () => {
      const { getByTestId } = render(<Component origin="N" direction="W" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(50, 0, translate3d(-100%, -50%, 0))");
    });

    it("returns the position for direction NW", () => {
      const { getByTestId } = render(<Component origin="N" direction="NW" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe(
        "(50, -10, translate3d(-100%, -100%, 0))"
      );
    });
  });

  describe("from origin NE", () => {
    it("returns the position for direction N", () => {
      const { getByTestId } = render(<Component origin="NE" direction="N" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe(
        "(100, -10, translate3d(-50%, -100%, 0))"
      );
    });

    it("returns the position for direction NE", () => {
      const { getByTestId } = render(<Component origin="NE" direction="NE" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe(
        "(100, -10, translate3d(0px, -100%, 0))"
      );
    });

    it("returns the position for direction E", () => {
      const { getByTestId } = render(<Component origin="NE" direction="E" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(110, 0, translate3d(0px, -50%, 0))");
    });

    it("returns the position for direction SE", () => {
      const { getByTestId } = render(<Component origin="NE" direction="SE" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(110, 0, translate3d(0px, 0px, 0))");
    });

    it("returns the position for direction S", () => {
      const { getByTestId } = render(<Component origin="NE" direction="S" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(100, 0, translate3d(-50%, 0px, 0))");
    });

    it("returns the position for direction SW", () => {
      const { getByTestId } = render(<Component origin="NE" direction="SW" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(100, 0, translate3d(-100%, 0px, 0))");
    });

    it("returns the position for direction W", () => {
      const { getByTestId } = render(<Component origin="NE" direction="W" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(100, 0, translate3d(-100%, -50%, 0))");
    });

    it("returns the position for direction NW", () => {
      const { getByTestId } = render(<Component origin="NE" direction="NW" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe(
        "(100, -10, translate3d(-100%, -100%, 0))"
      );
    });
  });

  describe("from origin E", () => {
    it("returns the position for direction N", () => {
      const { getByTestId } = render(<Component origin="E" direction="N" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe(
        "(100, 25, translate3d(-50%, -100%, 0))"
      );
    });

    it("returns the position for direction NE", () => {
      const { getByTestId } = render(<Component origin="E" direction="NE" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(110, 25, translate3d(0px, -100%, 0))");
    });

    it("returns the position for direction E", () => {
      const { getByTestId } = render(<Component origin="E" direction="E" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(110, 25, translate3d(0px, -50%, 0))");
    });

    it("returns the position for direction SE", () => {
      const { getByTestId } = render(<Component origin="E" direction="SE" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(110, 25, translate3d(0px, 0px, 0))");
    });

    it("returns the position for direction S", () => {
      const { getByTestId } = render(<Component origin="E" direction="S" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(100, 25, translate3d(-50%, 0px, 0))");
    });

    it("returns the position for direction SW", () => {
      const { getByTestId } = render(<Component origin="E" direction="SW" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(100, 25, translate3d(-100%, 0px, 0))");
    });

    it("returns the position for direction W", () => {
      const { getByTestId } = render(<Component origin="E" direction="W" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe(
        "(100, 25, translate3d(-100%, -50%, 0))"
      );
    });

    it("returns the position for direction NW", () => {
      const { getByTestId } = render(<Component origin="E" direction="NW" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe(
        "(100, 25, translate3d(-100%, -100%, 0))"
      );
    });
  });

  describe("from origin SE", () => {
    it("returns the position for direction N", () => {
      const { getByTestId } = render(<Component origin="SE" direction="N" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe(
        "(100, 50, translate3d(-50%, -100%, 0))"
      );
    });

    it("returns the position for direction NE", () => {
      const { getByTestId } = render(<Component origin="SE" direction="NE" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(110, 50, translate3d(0px, -100%, 0))");
    });

    it("returns the position for direction E", () => {
      const { getByTestId } = render(<Component origin="SE" direction="E" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(110, 50, translate3d(0px, -50%, 0))");
    });

    it("returns the position for direction SE", () => {
      const { getByTestId } = render(<Component origin="SE" direction="SE" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(100, 60, translate3d(0px, 0px, 0))");
    });

    it("returns the position for direction S", () => {
      const { getByTestId } = render(<Component origin="SE" direction="S" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(100, 60, translate3d(-50%, 0px, 0))");
    });

    it("returns the position for direction SW", () => {
      const { getByTestId } = render(<Component origin="SE" direction="SW" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(100, 60, translate3d(-100%, 0px, 0))");
    });

    it("returns the position for direction W", () => {
      const { getByTestId } = render(<Component origin="SE" direction="W" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe(
        "(100, 50, translate3d(-100%, -50%, 0))"
      );
    });

    it("returns the position for direction NW", () => {
      const { getByTestId } = render(<Component origin="SE" direction="NW" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe(
        "(100, 50, translate3d(-100%, -100%, 0))"
      );
    });
  });

  describe("from origin S", () => {
    it("returns the position for direction N", () => {
      const { getByTestId } = render(<Component origin="S" direction="N" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(50, 50, translate3d(-50%, -100%, 0))");
    });

    it("returns the position for direction NE", () => {
      const { getByTestId } = render(<Component origin="S" direction="NE" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(50, 50, translate3d(0px, -100%, 0))");
    });

    it("returns the position for direction E", () => {
      const { getByTestId } = render(<Component origin="S" direction="E" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(50, 50, translate3d(0px, -50%, 0))");
    });

    it("returns the position for direction SE", () => {
      const { getByTestId } = render(<Component origin="S" direction="SE" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(50, 60, translate3d(0px, 0px, 0))");
    });

    it("returns the position for direction S", () => {
      const { getByTestId } = render(<Component origin="S" direction="S" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(50, 60, translate3d(-50%, 0px, 0))");
    });

    it("returns the position for direction SW", () => {
      const { getByTestId } = render(<Component origin="S" direction="SW" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(50, 60, translate3d(-100%, 0px, 0))");
    });

    it("returns the position for direction W", () => {
      const { getByTestId } = render(<Component origin="S" direction="W" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(50, 50, translate3d(-100%, -50%, 0))");
    });

    it("returns the position for direction NW", () => {
      const { getByTestId } = render(<Component origin="S" direction="NW" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe(
        "(50, 50, translate3d(-100%, -100%, 0))"
      );
    });
  });

  describe("from origin SW", () => {
    it("returns the position for direction N", () => {
      const { getByTestId } = render(<Component origin="SW" direction="N" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(0, 50, translate3d(-50%, -100%, 0))");
    });

    it("returns the position for direction NE", () => {
      const { getByTestId } = render(<Component origin="SW" direction="NE" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(0, 50, translate3d(0px, -100%, 0))");
    });

    it("returns the position for direction E", () => {
      const { getByTestId } = render(<Component origin="SW" direction="E" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(0, 50, translate3d(0px, -50%, 0))");
    });

    it("returns the position for direction SE", () => {
      const { getByTestId } = render(<Component origin="SW" direction="SE" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(0, 60, translate3d(0px, 0px, 0))");
    });

    it("returns the position for direction S", () => {
      const { getByTestId } = render(<Component origin="SW" direction="S" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(0, 60, translate3d(-50%, 0px, 0))");
    });

    it("returns the position for direction SW", () => {
      const { getByTestId } = render(<Component origin="SW" direction="SW" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(0, 60, translate3d(-100%, 0px, 0))");
    });

    it("returns the position for direction W", () => {
      const { getByTestId } = render(<Component origin="SW" direction="W" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe(
        "(-10, 50, translate3d(-100%, -50%, 0))"
      );
    });

    it("returns the position for direction NW", () => {
      const { getByTestId } = render(<Component origin="SW" direction="NW" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe(
        "(-10, 50, translate3d(-100%, -100%, 0))"
      );
    });
  });

  describe("from origin W", () => {
    it("returns the position for direction N", () => {
      const { getByTestId } = render(<Component origin="W" direction="N" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(0, 25, translate3d(-50%, -100%, 0))");
    });

    it("returns the position for direction NE", () => {
      const { getByTestId } = render(<Component origin="W" direction="NE" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(0, 25, translate3d(0px, -100%, 0))");
    });

    it("returns the position for direction E", () => {
      const { getByTestId } = render(<Component origin="W" direction="E" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(0, 25, translate3d(0px, -50%, 0))");
    });

    it("returns the position for direction SE", () => {
      const { getByTestId } = render(<Component origin="W" direction="SE" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(0, 25, translate3d(0px, 0px, 0))");
    });

    it("returns the position for direction S", () => {
      const { getByTestId } = render(<Component origin="W" direction="S" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(0, 25, translate3d(-50%, 0px, 0))");
    });

    it("returns the position for direction SW", () => {
      const { getByTestId } = render(<Component origin="W" direction="SW" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(-10, 25, translate3d(-100%, 0px, 0))");
    });

    it("returns the position for direction W", () => {
      const { getByTestId } = render(<Component origin="W" direction="W" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe(
        "(-10, 25, translate3d(-100%, -50%, 0))"
      );
    });

    it("returns the position for direction NW", () => {
      const { getByTestId } = render(<Component origin="W" direction="NW" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe(
        "(-10, 25, translate3d(-100%, -100%, 0))"
      );
    });
  });

  describe("from origin NW", () => {
    it("returns the position for direction N", () => {
      const { getByTestId } = render(<Component origin="NW" direction="N" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(0, -10, translate3d(-50%, -100%, 0))");
    });

    it("returns the position for direction NE", () => {
      const { getByTestId } = render(<Component origin="NW" direction="NE" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(0, -10, translate3d(0px, -100%, 0))");
    });

    it("returns the position for direction E", () => {
      const { getByTestId } = render(<Component origin="NW" direction="E" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(0, 0, translate3d(0px, -50%, 0))");
    });

    it("returns the position for direction SE", () => {
      const { getByTestId } = render(<Component origin="NW" direction="SE" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(0, 0, translate3d(0px, 0px, 0))");
    });

    it("returns the position for direction S", () => {
      const { getByTestId } = render(<Component origin="NW" direction="S" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(0, 0, translate3d(-50%, 0px, 0))");
    });

    it("returns the position for direction SW", () => {
      const { getByTestId } = render(<Component origin="NW" direction="SW" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(-10, 0, translate3d(-100%, 0px, 0))");
    });

    it("returns the position for direction W", () => {
      const { getByTestId } = render(<Component origin="NW" direction="W" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(-10, 0, translate3d(-100%, -50%, 0))");
    });

    it("returns the position for direction NW", () => {
      const { getByTestId } = render(<Component origin="NW" direction="NW" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe(
        "(0, -10, translate3d(-100%, -100%, 0))"
      );
    });
  });

  describe("when it is outside the viewport", () => {
    it("does not return the expected position", () => {
      const { getByTestId } = render(<Component origin="NW" direction="NW" />);
      const content = getByTestId("position");
      mockAllIsIntersecting(false);

      expect(content.textContent).not.toBe(
        "(0, -10, translate3d(-100%, -100%, 0))"
      );
    });

    it("handles special origin and direction positions as NX", () => {
      const { getByTestId } = render(
        <Component
          origin={"NX" as CardinalPoint}
          direction={"NX" as CardinalPoint}
        />
      );
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(4, -10, translate3d(0px, -100%, 0))");
    });

    it("handles special origin and direction positions as SX", () => {
      const { getByTestId } = render(
        <Component
          origin={"SX" as CardinalPoint}
          direction={"SX" as CardinalPoint}
        />
      );
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(4, 60, translate3d(0px, 0px, 0))");
    });

    it("handles special origin and direction positions as XE", () => {
      const { getByTestId } = render(
        <Component
          origin={"XE" as CardinalPoint}
          direction={"XE" as CardinalPoint}
        />
      );
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(110, 4, translate3d(0px, 0px, 0))");
    });

    it("handles special origin and direction positions as XW", () => {
      const { getByTestId } = render(
        <Component
          origin={"XW" as CardinalPoint}
          direction={"XW" as CardinalPoint}
        />
      );
      const content = getByTestId("position");
      mockAllIsIntersecting(true);

      expect(content.textContent).toBe("(-10, 4, translate3d(-100%, 0px, 0))");
    });
  });
});
